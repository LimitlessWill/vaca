// -*- C++ -*-

/**

@page index

@image html Vaca.gif

@b Consideration: I speak Spanish and I don't know how to write in English.
   	          This documentation is only a draft. This is not a literary
		  novel, it's just a document to know what the library does.
		  If you find a mistake, please, <a href="http://www.davidcapello.com.ar/mail/">report it to me</a>.

@b Warning: This library is under development, this is not a stable
release. The API is mutating in the current development stage. Please,
if you want to use this library for real work be careful, or wait the first
stable release (from there we'll maintain backward compability).

This library is licensed under the terms of the @ref license "BSD license".

<h2>Introduction</h2>

Vaca is a library to wrap the Win32 API with C++ classes. Also, it's
has some extra functionalities like dockable tool bars and layout
managers. This library uses templates and STL (but not generic
programming).

<h2>Objetives</h2>

@li Fit design to make programming more easy.
@li Constructors must construct, if I do @c "new MyWindow()", then my
    window must be created (see @ref TN002).
@li Documentation for every tricky situation, its solution, and
    examples.
@li Technical Notes about how more common (or uncommon) problems were solved.

<h2>Message &mdash; Event &mdash; Signal (MES) Architecture</h2>

Definitions:

- A @em message is a message received from Windows (e.g. @c WM_KEYUP).
- An @em event is a virtual method (e.g. @c #Vaca::Widget::onKeyUp method).
- A @em signal is a variable member which anybody can connect their callbacks
  (e.g. @c #Vaca::Widget::KeyDown signal).

General behavior:

- A @em message is received from Windows OS with a @c WM_ constant value (e.g. @c WM_PAINT).
- A global WndProc (@ref Vaca::Widget::getGlobalWndProc) extracts the @c GWL_USERDATA
  from the @c HWND that received the message.
- In the @c GWL_USERDATA is located an instance of the #Vaca::Widget class
  (<b>new versions of Vaca stores the Widget pointer in the "VacaAtom" property</b>, see
  #Vaca::Widget::fromHWND for more information).
- This instance is used to call the #Vaca::Widget::wndProc method to process
  the message.
- Depending the message it calls other method (an @em event) that can be override
  (like #Vaca::Widget::onPaint, #Vaca::Widget::onResize, etc.).
- Some default implementations of the events fire a @em signal related to the event.
- The signal can be intercepted by anyone (like a C# delegate).
- Signals are the only variable members of classes that should be public, and their
  names must begin with a capital letter (like #Vaca::Button::Action).

Generally in Vaca we define virtual methods to handle events in the
widget itself, and signals for events that should be intercepted by
the parent window. Maybe in the future, signals will exist for every
event (like events and delegates in .NET framework).

@image html MES.png

<h2>Alternatives</h2>

<h3>MFC</h3>

MFC needs message maps. They are ugly, they are evil, I just don't
like it. You can't modify message maps in run-time. It's too hard to
program with message maps when you don't have the Visual C++ editor.
Do you try to remember all that macros? Impossible.

<h3>wxWidgets</h3>

Same as MFC, but it's free. It don't use C++ templates (and so STL
containers). Anyway this could be a good alternative for really big
projects.

<h3>GTK</h3>

It doesn't support the native look and feel of Windows.

<h3>Qt</h3>

License problem for the Windows version. Also it needs a
pre-precompiler to use the new language: C+++

<h3>SmartWin++</h3>

Generic programming is good, I really don't known how much good them
can be for GUI programming. Keep tracking this library, could be better
what we think.

<h3>Add here your favorite one...</h3>

Sure that I forget a lot of libraries (like Fox, fltk, VCF,
Windows++. etc.), but each one has something that I didn't like it.
Generally, one thing that I don't like of some libraries is the fact
that they have a (poor) visual editor that ("generally") is developed
using other library (or other language like C#).

<h2>Why other library?</h2>

Having so many options to choose, the question is obligatory, so why
to create another library?

A long time ago I was tried to find some library to program under
Windows using C++ that is relatively small as much in source code as
in the final size of the generated executable files (and all of this
without having license problems). There are situations where you must
develop a relatively small piece of software but you can't because:

(a) The user has Windows. \n
(b) You don't have the money to buy products like the Microsoft Visual Studio .NET. \n
(c) You don't have enough time to program with all the difficulties of wxWidgets or GTK.

So what we can do? A new library.

<h2>Unicode support</h2>

See @ref TN008.

<h2>Platforms</h2>

@li Win95 and WinNT4 are not supported (at least, I'm not thinking to
    add support for them).
@li Tested on Win98, Win2K, and WinXP.
@li Compiled with Mingw (GCC 3.4.2) and VC 7.1.

*/
