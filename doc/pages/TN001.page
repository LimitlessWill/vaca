// -*- C++ -*-

/**

@english
@page TN001 TN001: RegisterClass process

Vaca creates HWNDs in C++ constructors, one implication of this is
that the RegisterClass must be called before an
@ref Vaca::Widget "Widget" constructor.

Some libraries, uses a @c create method to really create the
widget (call the CreateWindowEx). I don't like it, mainly because
you can't do things like:

@code
class MyDialog : public Dialog {
  Label m_label;
  Button m_ok;
public:
  MyDialog() : Dialog(...)
             , m_label(...) {
             , m_ok(...) {
    // done
  }
};
@endcode

Generally, the most ugly case is this one:

@code
class MyDialog : public Dialog {
  Label *m_label;
  Button *m_ok;
public:
  MyDialog() {
    m_label = NULL;
    m_ok = NULL;
    ...
  }
  void create(...) {
    m_label = new Label();
    m_label->create(...);
    m_ok = new Button();
    m_ok->create(...);
    ...
  }
};
@endcode

Vaca avoid to do that, and try to make your life "easy" (like the
first example).

Anyway, this has serious implications for the internal Vaca
implementation, making the process to register a Win32 class a
"little" tricky. This is mainly because the
@ref Vaca::Widget::Widget() "constructor of the Vaca::Widget" class creates
the HWND (calls CreateWindowEx), so to create a HWND in the constructor of
a C++ class, we must register the Win32 classes with RegisterClass or
RegisterClassEx before that.

The only way to call RegisterClass @em automatically and before the
C++ class constructor is to inherit first from other class where its
constructor registers the Win32 class because it is called first.
With Vaca::Register and a customized Vaca::WidgetClass, you can
register your own widget class before to contruct it.
@endenglish



@spanish
@page TN001 TN001 - Proceso de registración de clases (RegisterClass)

Vaca crea los HWNDs mediante CreateWindow, en el mismo constructor de
Widget (<see cref="Widget::Widget"/>), esto implica que RegisterClass
deba ser llamado antes que dicho constructor.

Algunas bibliotecas (como MFC), usan un método @c create para realmente
crear el widget (llamar a CreateWindowEx). Personalmente no me gusta esto,
principalmente porque no se pueden hacer cosas como:

@code
class MyDialog : public Dialog {
  Label m_label;
  Button m_ok;
public:
  MyDialog() : Dialog(...)
             , m_label(...) {
             , m_ok(...) {
    // done
  }
};
@endcode

Generalmente, su código termina siendo mucho menos entendible como:

@code
class MyDialog : public Dialog {
  Label *m_label;
  Button *m_ok;
public:
  MyDialog() {
    m_label = NULL;
    m_ok = NULL;
    ...
  }
  void create(...) {
    m_label = new Label();
    m_label->create(...);
    m_ok = new Button();
    m_ok->create(...);
    ...
  }
};
@endcode

Vaca evita esto último, intentando hacer su vida más sencilla (como lo muestra
el primer ejemplo).

De todas formas, esto no es nada sencillo e implica serias decisiones
en el diseño de la biblioteca, requiriendo de algunos trucos
sucios. Por ejemplo, el proceso para registrar una clase Win32 es algo
complicado, se debe principalmente a que el constructor @ref Vaca::Widget::Widget()
crea directamente el HWND (llamando CreateWindowEx), así para crear un HWND,
antes debemos registrar la clase Win32 mediante RegisterClass o RegisterClassEx.

La única forma de llamar RegisterClass @em automáticamente y antes que
el constructor de la clase Vaca::Widget::Widget, es utilizando herencia
múltiple primero con otra clase, la cual tenga como objetivo registrar
la clase Win32. Esta tarea la realiza la clase @em template: Vaca::Register,
que como parámetro de @em template usa un Vaca::WidgetClass.
@endspanish

@see @ref TN002

*/
