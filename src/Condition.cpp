// -------------------- Original code from Boost --------------------
// Copyright (C) 2001-2003
// William E. Kempf
//
//  Distributed under the Boost Software License, Version 1.0. (See accompanying 
//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//
// Boost Software License - Version 1.0 - August 17th, 2003
// 
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
// ------------------------------------------------------------------
// 
// Vaca - Visual Application Components Abstraction
// Adapted by David A. Capello

#include "Vaca/Condition.hpp"
#include "Vaca/ScopedLock.hpp"

using namespace Vaca;

class ScopedUnlock : private NonCopyable
{
  ScopedLock& m_lock;
public:
  ScopedUnlock(ScopedLock& lock) : m_lock(lock)
  { m_lock.getMutex().unlock(); }
  ~ScopedUnlock()
  { m_lock.getMutex().lock(); }
};

Condition::Condition()
  : m_gone(0)
  , m_blocked(0)
  , m_waiting(0)
{
  m_gate = reinterpret_cast<void*>(CreateSemaphore(0, 1, 1, 0));
  m_queue = reinterpret_cast<void*>(CreateSemaphore(0, 0, (std::numeric_limits<long>::max)(), 0));
  m_mutex = reinterpret_cast<void*>(CreateMutex(0, 0, 0));

  if (!m_gate || !m_queue || !m_mutex) {
    if (m_gate) CloseHandle(reinterpret_cast<HANDLE>(m_gate));
    if (m_queue) CloseHandle(reinterpret_cast<HANDLE>(m_queue));
    if (m_mutex) CloseHandle(reinterpret_cast<HANDLE>(m_mutex));
    throw CreateConditionException();
  }
}

Condition::~Condition()
{
  CloseHandle(reinterpret_cast<HANDLE>(m_gate));
  CloseHandle(reinterpret_cast<HANDLE>(m_queue));
  CloseHandle(reinterpret_cast<HANDLE>(m_mutex));
}

void Condition::notifyOne()
{
  unsigned signals = 0;

  int res = 0;
  res = WaitForSingleObject(reinterpret_cast<HANDLE>(m_mutex), INFINITE);
  assert(res == WAIT_OBJECT_0);

  if (m_waiting != 0) { // the m_gate is already closed
    if (m_blocked == 0)
      {
	res = ReleaseMutex(reinterpret_cast<HANDLE>(m_mutex));
	assert(res);
	return;
      }

    ++m_waiting;
    --m_blocked;
    signals = 1;
  }
  else {
    res = WaitForSingleObject(reinterpret_cast<HANDLE>(m_gate), INFINITE);
    assert(res == WAIT_OBJECT_0);
    if (m_blocked > m_gone) {
      if (m_gone != 0) {
	m_blocked -= m_gone;
	m_gone = 0;
      }
      signals = m_waiting = 1;
      --m_blocked;
    }
    else {
      res = ReleaseSemaphore(reinterpret_cast<HANDLE>(m_gate), 1, 0);
      assert(res);
    }
  }

  res = ReleaseMutex(reinterpret_cast<HANDLE>(m_mutex));
  assert(res);

  if (signals) {
    res = ReleaseSemaphore(reinterpret_cast<HANDLE>(m_queue), signals, 0);
    assert(res);
  }
}

void Condition::notifyAll()
{
  unsigned signals = 0;

  int res = 0;
  res = WaitForSingleObject(reinterpret_cast<HANDLE>(m_mutex), INFINITE);
  assert(res == WAIT_OBJECT_0);

  if (m_waiting != 0) { // the m_gate is already closed
    if (m_blocked == 0) {
      res = ReleaseMutex(reinterpret_cast<HANDLE>(m_mutex));
      assert(res);
      return;
    }

    m_waiting += (signals = m_blocked);
    m_blocked = 0;
  }
  else {
    res = WaitForSingleObject(reinterpret_cast<HANDLE>(m_gate), INFINITE);
    assert(res == WAIT_OBJECT_0);
    if (m_blocked > m_gone) {
      if (m_gone != 0) {
	m_blocked -= m_gone;
	m_gone = 0;
      }
      signals = m_waiting = m_blocked;
      m_blocked = 0;
    }
    else {
      res = ReleaseSemaphore(reinterpret_cast<HANDLE>(m_gate), 1, 0);
      assert(res);
    }
  }

  res = ReleaseMutex(reinterpret_cast<HANDLE>(m_mutex));
  assert(res);

  if (signals) {
    res = ReleaseSemaphore(reinterpret_cast<HANDLE>(m_queue), signals, 0);
    assert(res);
  }
}

void Condition::wait(ScopedLock& lock)
{
  enterWait();
  ScopedUnlock unlock(lock);

  int res = 0;
  res = WaitForSingleObject(reinterpret_cast<HANDLE>(m_queue), INFINITE);
  assert(res == WAIT_OBJECT_0);

  unsigned was_waiting=0;
  unsigned was_gone=0;

  res = WaitForSingleObject(reinterpret_cast<HANDLE>(m_mutex), INFINITE);
  assert(res == WAIT_OBJECT_0);
  was_waiting = m_waiting;
  was_gone = m_gone;
  if (was_waiting != 0) {
    if (--m_waiting == 0) {
      if (m_blocked != 0) {
	res = ReleaseSemaphore(reinterpret_cast<HANDLE>(m_gate), 1,
			       0); // open m_gate
	assert(res);
	was_waiting = 0;
      }
      else if (m_gone != 0)
	m_gone = 0;
    }
  }
  else if (++m_gone == ((std::numeric_limits<unsigned>::max)() / 2)) {
    // timeout occured, normalize the m_gone count
    // this may occur if many calls to wait with a timeout are made and
    // no call to notify_* is made
    res = WaitForSingleObject(reinterpret_cast<HANDLE>(m_gate), INFINITE);
    assert(res == WAIT_OBJECT_0);
    m_blocked -= m_gone;
    res = ReleaseSemaphore(reinterpret_cast<HANDLE>(m_gate), 1, 0);
    assert(res);
    m_gone = 0;
  }
  res = ReleaseMutex(reinterpret_cast<HANDLE>(m_mutex));
  assert(res);

  if (was_waiting == 1) {
    for (/**/ ; was_gone; --was_gone) {
      // better now than spurious later
      res = WaitForSingleObject(reinterpret_cast<HANDLE>(m_queue),
				INFINITE);
      assert(res == WAIT_OBJECT_0);
    }
    res = ReleaseSemaphore(reinterpret_cast<HANDLE>(m_gate), 1, 0);
    assert(res);
  }
}

bool Condition::waitFor(ScopedLock& lock, double seconds)
{
  enterWait();
  ScopedUnlock unlock(lock);

  bool ret = false;
  unsigned int res = 0;

  // for (;;) {
    int milliseconds = static_cast<int>(seconds*1000.0);

    res = WaitForSingleObject(reinterpret_cast<HANDLE>(m_queue),
			      milliseconds);
    assert(res != WAIT_FAILED && res != WAIT_ABANDONED);
    ret = (res == WAIT_OBJECT_0);

    // if (res == WAIT_TIMEOUT) {
    //   xtime cur;
    //   xtime_get(&cur, TIME_UTC);
    //   if (xtime_cmp(xt, cur) > 0)
    // 	continue;
    // }

  //   break;
  // }

  unsigned was_waiting=0;
  unsigned was_gone=0;

  res = WaitForSingleObject(reinterpret_cast<HANDLE>(m_mutex), INFINITE);
  assert(res == WAIT_OBJECT_0);
  was_waiting = m_waiting;
  was_gone = m_gone;
  if (was_waiting != 0) {
    if (!ret) { // timeout
      if (m_blocked != 0)
	--m_blocked;
      else
	++m_gone; // count spurious wakeups
    }
    if (--m_waiting == 0) {
      if (m_blocked != 0) {
	res = ReleaseSemaphore(reinterpret_cast<HANDLE>(m_gate), 1,
			       0); // open m_gate
	assert(res);
	was_waiting = 0;
      }
      else if (m_gone != 0)
	m_gone = 0;
    }
  }
  else if (++m_gone == ((std::numeric_limits<unsigned>::max)() / 2)) {
    // timeout occured, normalize the m_gone count
    // this may occur if many calls to wait with a timeout are made and
    // no call to notify_* is made
    res = WaitForSingleObject(reinterpret_cast<HANDLE>(m_gate), INFINITE);
    assert(res == WAIT_OBJECT_0);
    m_blocked -= m_gone;
    res = ReleaseSemaphore(reinterpret_cast<HANDLE>(m_gate), 1, 0);
    assert(res);
    m_gone = 0;
  }
  res = ReleaseMutex(reinterpret_cast<HANDLE>(m_mutex));
  assert(res);

  if (was_waiting == 1) {
    for (/**/ ; was_gone; --was_gone) {
      // better now than spurious later
      res = WaitForSingleObject(reinterpret_cast<HANDLE>(m_queue),
				INFINITE);
      assert(res ==  WAIT_OBJECT_0);
    }
    res = ReleaseSemaphore(reinterpret_cast<HANDLE>(m_gate), 1, 0);
    assert(res);
  }

  return ret;
}

void Condition::enterWait()
{
  int res = 0;
  res = WaitForSingleObject(reinterpret_cast<HANDLE>(m_gate), INFINITE);
  assert(res == WAIT_OBJECT_0);
  ++m_blocked;
  res = ReleaseSemaphore(reinterpret_cast<HANDLE>(m_gate), 1, 0);
  assert(res);
}
